06 Полиморфизъм

# 1 Полиморфизъм

* дефиниция: възможността да представяме обектите 
  като обекти от техен родителски клас
* под представяне, разбираме подаване на обекта
  като аргумент във фунция
* под родителски тип (клас) имаме предвид който
  и да е пра-родител
* принцип в ооп
* наследяването е задължително за да имаме полиморфизъм

* ако фунция има за параметрър обект,
  който е очаквана инстанция на клас А,
  тя може да работи и ако подадем инстанция
  от клас-наследник на А, без това да доведе
  до предупреждение от Pycharm
  
* абстракция <-> конкретика
* пм създава абстракция


# 2 Абстракция

* а ни дава възможност да пишем код без да се интересуваме
  от конкретната имплементация
* пример: когато шофирме кола ни интересува как да я
  използваме, не е нужно да разбираме устройството на
  двигател, ходова част...
* пример 2: frond end получава данни от back end, не се
  интересува дали be е написан на питон, джава...

* полза: намалява сложността; получаваме част от
  информацията, която ни интересува 
* абстракция = принцип в ООП

## 2.2 Абстрактни класове

* а кл = клас с абстрактни методи
* а мет = няма имплементация(т.е. кодът, който произвежда изхода)

* абстрактния клас не може да се инстанцира
  (да се създават обекти), целта му е да бъде наследен
* а кл е като скелет; абстрактиния кл задава поведението
което после всеки наследник имплементира
  
* можем да направим клас абстрактен като при подаване на обект
от класа вдигаме грешка - не питонско
* питонски начин е abc модула

*абстрактните класове дават strong type полиморфизъм
(задължително трябва в наследника всички @abstractmethod-и
да се пре-напишат)

* да не се пре-написва инит-а при наследници, ако не
се създават нови дейта атрибути
  
* абстрактен метод никога неможе да бъде изпълнен, 
  той задължава наследници да го пре-напишат = да 
  направят имплементация = как да се реализира

# 3 Duck-typing

* концепция в динамично-типизираните езици (питон, JS)
* стил на писане на код

* коцепцията е че типът (класът) на обект е по-малко важен от
методите на обекта
* когато ползваме този стил, не проверяваме за типа на обекта,
вместо това търсим налиние на определен метод или атрибут

* пример: фунцията лен не се интересува какъв е типа на
  аргумента, а дали има метод __ лен __
* Алтернатива на полиморфизма, по-айляшки


* няма смисил в практиката да правим родителски клас само
за да опишем абстрактни методи. Има смисъл ако има и имплементирани
  методи (които ще се наследят и ползват от наследниците).

# 4 Магически методи

* методи, който имат __ преди и след името на метода
* методът замества запис с оператори и литерали като + - ();
  това важи в почти (ако не и всички) случай
* operator overloading
* `презаписване` = override

